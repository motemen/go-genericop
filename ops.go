// auto-generated by _tools/generate.go

package genericop

import (
	"fmt"
)

// Add is a generic operator function for "+".
func Add(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(complex128); ok {
		if y_, ok := y.(complex128); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(complex64); ok {
		if y_, ok := y.(complex64); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	if x_, ok := x.(string); ok {
		if y_, ok := y.(string); ok {
			r = x_ + y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "+", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "+", y)
	return
}

// Sub is a generic operator function for "-".
func Sub(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(complex128); ok {
		if y_, ok := y.(complex128); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(complex64); ok {
		if y_, ok := y.(complex64); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ - y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "-", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "-", y)
	return
}

// Mul is a generic operator function for "*".
func Mul(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(complex128); ok {
		if y_, ok := y.(complex128); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(complex64); ok {
		if y_, ok := y.(complex64); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ * y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "*", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "*", y)
	return
}

// Quo is a generic operator function for "/".
func Quo(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(complex128); ok {
		if y_, ok := y.(complex128); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(complex64); ok {
		if y_, ok := y.(complex64); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ / y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "/", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "/", y)
	return
}

// Rem is a generic operator function for "%".
func Rem(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ % y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "%", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "%", y)
	return
}

// And is a generic operator function for "&".
func And(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ & y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "&", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "&", y)
	return
}

// Or is a generic operator function for "|".
func Or(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ | y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "|", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "|", y)
	return
}

// Xor is a generic operator function for "^".
func Xor(x, y interface{}) (r interface{}, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ ^ y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "^", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "^", y)
	return
}

// Lt is a generic operator function for "<".
func Lt(x, y interface{}) (r bool, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(string); ok {
		if y_, ok := y.(string); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ < y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "<", y)
	return
}

// Gt is a generic operator function for ">".
func Gt(x, y interface{}) (r bool, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(string); ok {
		if y_, ok := y.(string); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ > y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, ">", y)
	return
}

// Le is a generic operator function for "<=".
func Le(x, y interface{}) (r bool, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(string); ok {
		if y_, ok := y.(string); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ <= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, "<=", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, "<=", y)
	return
}

// Ge is a generic operator function for ">=".
func Ge(x, y interface{}) (r bool, err error) {
	if x_, ok := x.(byte); ok {
		if y_, ok := y.(byte); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(float32); ok {
		if y_, ok := y.(float32); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(float64); ok {
		if y_, ok := y.(float64); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(int); ok {
		if y_, ok := y.(int); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(int16); ok {
		if y_, ok := y.(int16); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(int32); ok {
		if y_, ok := y.(int32); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(int64); ok {
		if y_, ok := y.(int64); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(int8); ok {
		if y_, ok := y.(int8); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(rune); ok {
		if y_, ok := y.(rune); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(string); ok {
		if y_, ok := y.(string); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(uint); ok {
		if y_, ok := y.(uint); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(uint16); ok {
		if y_, ok := y.(uint16); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(uint32); ok {
		if y_, ok := y.(uint32); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(uint64); ok {
		if y_, ok := y.(uint64); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(uint8); ok {
		if y_, ok := y.(uint8); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	if x_, ok := x.(uintptr); ok {
		if y_, ok := y.(uintptr); ok {
			r = x_ >= y_
		} else {
			err = fmt.Errorf("incompatible types: %T %s %T", x, ">=", y)
		}
		return
	}
	
	err = fmt.Errorf("no operation defined: %T %s %T", x, ">=", y)
	return
}


// MustBool receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Bool.
func MustBool(v interface{}, err error) bool {
	if err != nil {
		panic(err)
	}
	return v.(bool)
}

// MustByte receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Byte.
func MustByte(v interface{}, err error) byte {
	if err != nil {
		panic(err)
	}
	return v.(byte)
}

// MustComplex128 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Complex128.
func MustComplex128(v interface{}, err error) complex128 {
	if err != nil {
		panic(err)
	}
	return v.(complex128)
}

// MustComplex64 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Complex64.
func MustComplex64(v interface{}, err error) complex64 {
	if err != nil {
		panic(err)
	}
	return v.(complex64)
}

// MustFloat32 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Float32.
func MustFloat32(v interface{}, err error) float32 {
	if err != nil {
		panic(err)
	}
	return v.(float32)
}

// MustFloat64 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Float64.
func MustFloat64(v interface{}, err error) float64 {
	if err != nil {
		panic(err)
	}
	return v.(float64)
}

// MustInt receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Int.
func MustInt(v interface{}, err error) int {
	if err != nil {
		panic(err)
	}
	return v.(int)
}

// MustInt16 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Int16.
func MustInt16(v interface{}, err error) int16 {
	if err != nil {
		panic(err)
	}
	return v.(int16)
}

// MustInt32 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Int32.
func MustInt32(v interface{}, err error) int32 {
	if err != nil {
		panic(err)
	}
	return v.(int32)
}

// MustInt64 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Int64.
func MustInt64(v interface{}, err error) int64 {
	if err != nil {
		panic(err)
	}
	return v.(int64)
}

// MustInt8 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Int8.
func MustInt8(v interface{}, err error) int8 {
	if err != nil {
		panic(err)
	}
	return v.(int8)
}

// MustRune receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Rune.
func MustRune(v interface{}, err error) rune {
	if err != nil {
		panic(err)
	}
	return v.(rune)
}

// MustString receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type String.
func MustString(v interface{}, err error) string {
	if err != nil {
		panic(err)
	}
	return v.(string)
}

// MustUint receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Uint.
func MustUint(v interface{}, err error) uint {
	if err != nil {
		panic(err)
	}
	return v.(uint)
}

// MustUint16 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Uint16.
func MustUint16(v interface{}, err error) uint16 {
	if err != nil {
		panic(err)
	}
	return v.(uint16)
}

// MustUint32 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Uint32.
func MustUint32(v interface{}, err error) uint32 {
	if err != nil {
		panic(err)
	}
	return v.(uint32)
}

// MustUint64 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Uint64.
func MustUint64(v interface{}, err error) uint64 {
	if err != nil {
		panic(err)
	}
	return v.(uint64)
}

// MustUint8 receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Uint8.
func MustUint8(v interface{}, err error) uint8 {
	if err != nil {
		panic(err)
	}
	return v.(uint8)
}

// MustUintptr receives results from generic operators (e.g. Add)
// and panics if there was any error or the value was not of type Uintptr.
func MustUintptr(v interface{}, err error) uintptr {
	if err != nil {
		panic(err)
	}
	return v.(uintptr)
}

